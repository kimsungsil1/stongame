<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>바둑 게임 (Go) - AI 상대 & 간단 점수</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --bg-board: #d8a454;
      --bg-page: #f0f0f0;
      --grid-color: #000;
    }
    * { box-sizing: border-box; }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      font-family: sans-serif;
      background: var(--bg-page);
      margin: 0;
      padding: 1rem 0 3rem;
    }
    h1 { margin: 0; font-size: clamp(1.2rem, 4vw, 1.8rem); }
    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem 1rem;
      justify-content: center;
      align-items: center;
    }
    #controls select,
    #controls button {
      padding: 0.4rem 0.8rem;
      font-size: 1rem;
    }
    #boardWrapper {
      background: var(--bg-board);
      border-radius: 0.5rem;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      touch-action: manipulation;
    }
    canvas { display: block; height: auto; width: 100%; }
  </style>
</head>
<body>
  <h1>바둑 게임 (AI 상대)</h1>
  <div id="controls">
    <label for="sizeSelect">보드 크기:</label>
    <select id="sizeSelect">
      <option value="5">5×5</option>
      <option value="7">7×7</option>
      <option value="9">9×9</option>
      <option value="13">13×13</option>
      <option value="19" selected>19×19</option>
    </select>
    <button id="resetBtn">새 게임</button>
    <button id="resultBtn">결과 보기</button>
    <span id="turnInfo"></span>
  </div>
  <div id="boardWrapper">
    <canvas id="boardCanvas"></canvas>
  </div>

  <script>
    const canvas   = document.getElementById('boardCanvas');
    const ctx      = canvas.getContext('2d');
    const sizeSel  = document.getElementById('sizeSelect');
    const resetBtn = document.getElementById('resetBtn');
    const resultBtn= document.getElementById('resultBtn');
    const turnInfo = document.getElementById('turnInfo');
    const wrapper  = document.getElementById('boardWrapper');

    const HUMAN = 1;  // black ●
    const AI    = 2;  // white ○
    const stoneRadiusRatio = 0.4;

    let boardSize = parseInt(sizeSel.value);
    let board = [];
    let marginPx, cellPx;

    /* -------------------- helpers -------------------- */
    function cloneBoard(src){ return src.map(r=>r.slice()); }

    function neighbors(r,c){
      return [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([nr,nc])=>nr>=0&&nr<boardSize&&nc>=0&&nc<boardSize);
    }

    function groupAndLibs(bd, r,c,color,visited){
      const stack=[[r,c]], grp=[]; let libs=0; visited[r][c]=true;
      while(stack.length){
        const [cr,cc]=stack.pop(); grp.push([cr,cc]);
        for(const [nr,nc] of neighbors(cr,cc)){
          if(bd[nr][nc]===0) libs++;
          else if(bd[nr][nc]===color && !visited[nr][nc]){ visited[nr][nc]=true; stack.push([nr,nc]); }
        }
      }
      return {grp,libs};
    }

    function removeGroup(bd, grp){ for(const [r,c] of grp) bd[r][c]=0; }

    function tryPlace(bd,r,c,color){
      if(bd[r][c]!==0) return false;
      const opp = color===HUMAN?AI:HUMAN;
      bd[r][c]=color;
      for(const [nr,nc] of neighbors(r,c)){
        if(bd[nr][nc]===opp){
          const visited=bd.map(_=>Array(boardSize).fill(false));
          const {grp,libs}=groupAndLibs(bd,nr,nc,opp,visited);
          if(libs===0) removeGroup(bd,grp);
        }
      }
      const visitedSelf=bd.map(_=>Array(boardSize).fill(false));
      const {libs:selfLibs}=groupAndLibs(bd,r,c,color,visitedSelf);
      if(selfLibs===0){ bd[r][c]=0; return false; }
      return true;
    }

    /* -------------------- UI draw -------------------- */
    function calcDimensions(){
      const maxPx = Math.min(window.innerWidth*0.9, 600);
      cellPx = Math.floor(maxPx / boardSize);
      marginPx = cellPx;
      canvas.width = marginPx*2 + cellPx*(boardSize-1);
      canvas.height = canvas.width;
      wrapper.style.width = canvas.width+'px';
    }

    function drawBoard(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-color');
      ctx.lineWidth = 1;
      for(let i=0;i<boardSize;i++){
        ctx.beginPath();
        ctx.moveTo(marginPx + i*cellPx, marginPx);
        ctx.lineTo(marginPx + i*cellPx, marginPx + cellPx*(boardSize-1));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(marginPx, marginPx + i*cellPx);
        ctx.lineTo(marginPx + cellPx*(boardSize-1), marginPx + i*cellPx);
        ctx.stroke();
      }
      for(let r=0;r<boardSize;r++){
        for(let c=0;c<boardSize;c++){
          if(board[r][c]) drawStone(c,r,board[r][c]);
        }
      }
    }

    function drawStone(x,y,color){
      const cx = marginPx + x*cellPx;
      const cy = marginPx + y*cellPx;
      const r = cellPx*stoneRadiusRatio;
      ctx.beginPath();
      ctx.arc(cx,cy,r,0,Math.PI*2);
      ctx.fillStyle = color===HUMAN? '#000' : '#fff';
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.stroke();
    }

    function updateTurn(msg=""){
      turnInfo.textContent = msg || '당신 차례: ●';
    }

    /* -------------------- Game flow -------------------- */
    function initGame(){
      board = Array.from({length: boardSize}, _=>Array(boardSize).fill(0));
      calcDimensions();
      drawBoard();
      updateTurn();
    }

    function coord(evt){
      const rect=canvas.getBoundingClientRect();
      const x=(evt.touches?evt.touches[0].clientX:evt.clientX)-rect.left;
      const y=(evt.touches?evt.touches[0].clientY:evt.clientY)-rect.top;
      const col=Math.round((x-marginPx)/cellPx);
      const row=Math.round((y-marginPx)/cellPx);
      if(col>=0&&col<boardSize&&row>=0&&row<boardSize){
        const dx=x-(marginPx+col*cellPx);
        const dy=y-(marginPx+row*cellPx);
        if(Math.hypot(dx,dy)<cellPx*0.45) return {row,col};
      }
      return null;
    }

    function humanMove(evt){
      evt.preventDefault();
      const cc=coord(evt);
      if(!cc) return;
      const {row,col}=cc;
      if(!tryPlace(board,row,col,HUMAN)) return;
      drawBoard();
      updateTurn('AI 생각 중…');
      setTimeout(aiMove, 300);
    }

    function aiMove(){
      const legal=[];
      for(let r=0;r<boardSize;r++){
        for(let c=0;c<boardSize;c++){
          if(board[r][c]) continue;
          const tmp=cloneBoard(board);
          if(tryPlace(tmp,r,c,AI)) legal.push([r,c]);
        }
      }
      if(legal.length){
        const [r,c]=legal[Math.floor(Math.random()*legal.length)];
        tryPlace(board,r,c,AI);
        drawBoard();
      }
      updateTurn();
    }

    function simpleScore(){
      let black=0,white=0;
      for(let r=0;r<boardSize;r++){
        for(let c=0;c<boardSize;c++){
          if(board[r][c]===HUMAN) black++;
          else if(board[r][c]===AI) white++;
        }
      }
      let winner='무승부';
      if(black>white) winner='흑 승';
      else if(white>black) winner='백 승';
      return {black,white,winner};
    }

    /* -------------------- Event bindings -------------------- */
    canvas.addEventListener('click', humanMove);
    canvas.addEventListener('touchend', humanMove);
    sizeSel.addEventListener('change', ()=>{ boardSize=parseInt(sizeSel.value); initGame(); });
    resetBtn.addEventListener('click', initGame);
    resultBtn.addEventListener('click', ()=>{
      const {black,white,winner}=simpleScore();
      updateTurn(`흑 ${black} : 백 ${white} → ${winner}`);
      alert(`흑 ${black} : 백 ${white}\n${winner}!`);
    });
    window.addEventListener('resize', ()=>{ calcDimensions(); drawBoard(); });

    initGame();
  </script>
</body>
</html>
