<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>모바일 바둑 게임 (AI 상대)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --bg-board: #d8a454;
      --bg-page: #f0f0f0;
      --grid-color: #000;
    }
    * { box-sizing: border-box; }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      font-family: sans-serif;
      background: var(--bg-page);
      margin: 0;
      padding: 1rem 0 3rem;
    }
    h1 { margin: 0; font-size: clamp(1.2rem,4vw,1.8rem); }
    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem 1rem;
      justify-content: center;
      align-items: center;
    }
    select, button { padding: 0.4rem 0.8rem; font-size: 1rem; }
    #boardWrapper { background: var(--bg-board); border-radius: 0.5rem; box-shadow: 0 4px 10px rgba(0,0,0,0.2); touch-action: manipulation; }
    canvas { display: block; width: 100%; height: auto; }
  </style>
</head>
<body>
  <h1>바둑 게임 (AI 상대)</h1>
  <div id="controls">
    <label>보드:</label>
    <select id="sizeSelect">
      <option value="5">5×5</option>
      <option value="7">7×7</option>
      <option value="9">9×9</option>
      <option value="13">13×13</option>
      <option value="19" selected>19×19</option>
    </select>
    <label>AI:</label>
    <select id="aiLevel">
      <option value="easy">쉬움</option>
      <option value="medium" selected>보통</option>
      <option value="hard">어려움</option>
    </select>
    <button id="resetBtn">새 게임</button>
    <span id="turnInfo"></span>
  </div>
  <div id="boardWrapper"><canvas id="boardCanvas"></canvas></div>

  <script>
    // ---------- Constants ----------
    const HUMAN = 1; // black ●
    const AI    = 2; // white ○
    const stoneRadiusRatio = 0.4;

    // ---------- DOM refs ----------
    const canvas   = document.getElementById('boardCanvas');
    const ctx      = canvas.getContext('2d');
    const sizeSel  = document.getElementById('sizeSelect');
    const aiSel    = document.getElementById('aiLevel');
    const resetBtn = document.getElementById('resetBtn');
    const turnInfo = document.getElementById('turnInfo');
    const wrapper  = document.getElementById('boardWrapper');

    // ---------- Game state ----------
    let boardSize = parseInt(sizeSel.value);
    let board = []; // 0 empty / 1 black / 2 white
    let marginPx, cellPx;

    // ---------- Helper functions ----------
    const clone = (bd) => bd.map(r=>r.slice());
    const neighbors = (r,c) => [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([nr,nc])=>nr>=0&&nr<boardSize&&nc>=0&&nc<boardSize);

    function groupAndLibs(bd, r,c,color,vis){
      const st=[[r,c]], grp=[]; vis[r][c]=true; let libs=0;
      while(st.length){
        const [cr,cc]=st.pop(); grp.push([cr,cc]);
        for(const [nr,nc] of neighbors(cr,cc)){
          if(bd[nr][nc]===0) libs++;
          else if(bd[nr][nc]===color && !vis[nr][nc]){ vis[nr][nc]=true; st.push([nr,nc]); }
        }
      }
      return {grp,libs};
    }

    function removeGroup(bd, grp){ grp.forEach(([r,c])=>bd[r][c]=0); }

    function legalMove(bd,r,c,color){
      if(bd[r][c]!==0) return false;
      const opp=color===HUMAN?AI:HUMAN;
      bd[r][c]=color;
      // capture opp groups
      for(const [nr,nc] of neighbors(r,c)) if(bd[nr][nc]===opp){ const vis=bd.map(_=>Array(boardSize).fill(false)); const {grp,libs}=groupAndLibs(bd,nr,nc,opp,vis); if(libs===0) removeGroup(bd,grp); }
      // suicide check
      const visSelf=bd.map(_=>Array(boardSize).fill(false));
      const {libs}=groupAndLibs(bd,r,c,color,visSelf);
      if(libs===0){ bd[r][c]=0; return false; }
      return true;
    }

    function getLegalMoves(color){
      const moves=[];
      for(let r=0;r<boardSize;r++) for(let c=0;c<boardSize;c++) if(board[r][c]===0){ const tmp=clone(board); if(legalMove(tmp,r,c,color)) moves.push([r,c]); }
      return moves;
    }

    // ---------- Board / UI ----------
    function calcDim(){ const max=Math.min(window.innerWidth*0.9,600); cellPx=Math.floor(max/boardSize); marginPx=cellPx; canvas.width=marginPx*2+cellPx*(boardSize-1); canvas.height=canvas.width; wrapper.style.width=canvas.width+'px'; }

    function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid-color'); ctx.lineWidth=1; for(let i=0;i<boardSize;i++){ ctx.beginPath(); ctx.moveTo(marginPx+i*cellPx,marginPx); ctx.lineTo(marginPx+i*cellPx,marginPx+cellPx*(boardSize-1)); ctx.stroke(); ctx.beginPath(); ctx.moveTo(marginPx,marginPx+i*cellPx); ctx.lineTo(marginPx+cellPx*(boardSize-1),marginPx+i*cellPx); ctx.stroke(); } for(let r=0;r<boardSize;r++) for(let c=0;c<boardSize;c++) if(board[r][c]) drawStone(c,r,board[r][c]); }
    function drawStone(x,y,color){ const cx=marginPx+x*cellPx, cy=marginPx+y*cellPx, r=cellPx*stoneRadiusRatio; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fillStyle=color===HUMAN?"#000":"#fff"; ctx.fill(); ctx.strokeStyle="#000"; ctx.stroke(); }

    function setTurn(msg){ turnInfo.textContent=msg; }

    // ---------- Scoring ----------
    function scoreGame(){
      let bStone=0,wStone=0,bTer=0,wTer=0; const visited=Array.from({length:boardSize},_=>Array(boardSize).fill(false));
      for(let r=0;r<boardSize;r++) for(let c=0;c<boardSize;c++){
        if(board[r][c]===HUMAN) bStone++;
        else if(board[r][c]===AI) wStone++;
        else if(!visited[r][c]){
          // empty region
          const q=[[r,c]]; visited[r][c]=true; let empties=[[r,c]]; const adj=new Set();
          while(q.length){ const [cr,cc]=q.pop(); for(const [nr,nc] of neighbors(cr,cc)){ if(board[nr][nc]===0 && !visited[nr][nc]){ visited[nr][nc]=true; q.push([nr,nc]); empties.push([nr,nc]); } else if(board[nr][nc]!==0){ adj.add(board[nr][nc]); } } }
          if(adj.size===1){ const owner=[...adj][0]; if(owner===HUMAN) bTer+=empties.length; else wTer+=empties.length; }
        }
      }
      const bScore=bStone+bTer; const wScore=wStone+wTer; const diff=bScore-wScore; const winner=diff>0?"흑 승" : diff<0?"백 승":"무승부";
      return {bScore,wScore,diff,winner,bStone,wStone,bTer,wTer};
    }

    function showResult(){ const s=scoreGame(); const msg=`흑 ● ${s.bScore} (돌 ${s.bStone}+집 ${s.bTer})\n백 ○ ${s.wScore} (돌 ${s.wStone}+집 ${s.wTer})\n→ ${s.winner}`; alert(msg); setTurn(msg); }

    function checkEnd(){ if(board.flat().every(v=>v!==0)) return true; const humanMoves=getLegalMoves(HUMAN); const aiMoves=getLegalMoves(AI); return humanMoves.length===0 && aiMoves.length===0; }

    // ---------- AI ----------
    function aiMove(){ const level=aiSel.value; const moves=getLegalMoves(AI); if(!moves.length) return; let choice;
      if(level==='easy'){ choice=moves[Math.floor(Math.random()*moves.length)]; }
      else if(level==='medium'){ // maximize immediate captures
        let bestCap=-1; const cand=[];
        for(const [r,c] of moves){ const tmp=clone(board); const before=tmp.flat().filter(v=>v===HUMAN).length; legalMove(tmp,r,c,AI); const after=tmp.flat().filter(v=>v===HUMAN).length; const captured=before-after; if(captured>bestCap){ bestCap=captured; cand.length=0; cand.push([r,c]); } else if(captured===bestCap){ cand.push([r,c]); } }
        choice=cand[Math.floor(Math.random()*cand.length)]; }
      else { // hard: evaluate score diff after move, choose best
        let bestDiff=-Infinity; const cand=[];
        for(const [r,c] of moves){ const tmp=clone(board); legalMove(tmp,r,c,AI); const {bScore,wScore}=scoreGameTmp(tmp); const diff=wScore-bScore; if(diff>bestDiff){ bestDiff=diff; cand.length=0; cand.push([r,c]); } else if(diff===bestDiff){ cand.push([r,c]); } }
        choice=cand[Math.floor(Math.random()*cand.length)]; }
      legalMove(board,choice[0],choice[1],AI); draw(); if(checkEnd()) showResult(); else setTurn('당신 차례: ●'); }

    function scoreGameTmp(bd){ // simplified for AI eval (stones only to save time)
      let b=0,w=0; for(const v of bd.flat()){ if(v===HUMAN) b++; else if(v===AI) w++; } return {bScore:b,wScore:w}; }

    // ---------- Player ----------
    function coord(evt){ const rect=canvas.getBoundingClientRect(); const x=(evt.touches?evt.touches[0].clientX:evt.clientX)-rect.left; const y=(evt.touches?evt.touches[0].clientY:evt.clientY)-rect.top; const col=Math.round((x-marginPx)/cellPx); const row=Math.round((y-marginPx)/cellPx); if(col>=0&&col<boardSize&&row>=0&&row<boardSize){ const dx=x-(marginPx+col*cellPx); const dy=y-(marginPx+row*cellPx); if(Math.hypot(dx,dy)<cellPx*0.45) return [row,col]; } return null; }

    function humanPlay(evt){ evt.preventDefault(); const pos=coord(evt); if(!pos) return; const [r,c]=pos; if(!legalMove(board,r,c,HUMAN)) return; draw(); if(checkEnd()){ showResult(); return; } setTurn('AI 생각 중…'); setTimeout(()=>{ aiMove(); },300); }

    // ---------- Init / Reset ----------
    function init(){ board=Array.from({length:boardSize},_=>Array(boardSize).fill(0)); calcDim(); draw(); setTurn('당신 차례: ●'); }

    // ---------- Bindings ----------
    canvas.addEventListener('click', humanPlay);
    canvas.addEventListener('touchend', humanPlay);
    sizeSel.addEventListener('change', ()=>{ boardSize=parseInt(sizeSel.value); init(); });
    aiSel.addEventListener('change', ()=> setTurn('설정 변경됨, 계속 진행'));
    resetBtn.addEventListener('click', init);
    window.addEventListener('resize', ()=>{ calcDim(); draw(); });

    init();
  </script>
</body>
</html>
